# Disclaimer

В домашних заданиях вы можете менять сигнатуры методов/интерфейс, если на написано обратного. Если в задании нужно
реализовать определенную функцию, которая уже объявлена за вас, в таких случаях ее сигнатуру менять нельзя. То же
касается и интерфейсов/адт: если задана четкая структура с полями трейтов/классов, то ее можно только дополнять для
удобства вашего решения, но не менять кардинально.

## Важно: автоматические 0 баллов за работу, если:
* Сдано после дедлайна
* Красный CI (даже если падает только scalafmt)
* Если CI проходит, но было выполнено 0 тестов
* Есть правки в условии, которые не разрешены в условии
* Если есть действия после дедлайна, которые меняют код 

# Json Codecs

Ваша задача реализовать json парсер, <b>используя тайпклассы</b>.
Программа должна уметь парсить из/в Json:

* строки
* целые числа
* числа с плавающей запятой
* листы
* опциональные значения
* кастомные пользовательские типы

### Json

`Json` может быть отображен нулом, строкой, числами, массивом или json объектом

```scala
sealed trait Json

object Json {
  final case object JsonNull extends Json // Нужен для кодирования опциональных полей

  final case class JsonString(value: String) extends Json

  final case class JsonInt(value: Int) extends Json

  final case class JsonDouble(value: Double) extends Json

  final case class JsonArray(value: List[Json]) extends Json

  final case class JsonObject(value: Map[String, Json]) extends Json
}
```

Для каждого Json реализовать свой инстанс Show, для отображения его в виде строки как у привычного
json `{"key": "value"}`

### JsonWriter[A]

Этот тайпкласс может принимать значение типа `А` и трансформировать его в `Json` объект.
Также у него есть summoner и синтаксическое расширение для вызова `toJson` прямо на объекте типа `А`

Если для нужного типа B нет `JsonWriter[B]`, но при этом есть для типа `A :> B`, то должен
использоваться `JsonWriter[A]`, который сериализует только те поля, которые определены в объекте `A`

### JsonReader

Этот тайпкласс может принимать `Json` и возвращать объект типа `Right(А)`, сконструированный из `Json`. Либо первую
встреченную ошибку в `Left`.

Для списка объектов можно ограничиться только `JsonReader[List[A]]`, другие коллекции уметь парсить не нужно.

Ридер должен обладать подробным трекингом полей с ошибками:

- Если ридер встречает ошибку в листе сложных элементов (кейс классов), то в ошибке должен содержаться порядковый номер
  этого элемента и название поля с ошибкой.

```scala
case class Student(name: String, age: Int)

JsonReader[List[Student]].read(JsonArray(List(JsonObject(Map("name" -> "Vasya"))))) // выдаст ошибку вида AbsentField("[0].age")
```

- Если объект является вложенным в другой объект, то название родительского поля, в котором содержится объект с ошибкой,
  должно быть добавлено в описание ошибки

```scala
case Address(street: String, country: String)

case class Student(name: String, address: Address)

JsonReader[Student].read(JsonObject(Map("name" -> "Vasya", "address" -> JsonObject("street" -> "street"))))
// например выдаст ошибку вида AbsentField("address.country")
```

Текстовка ошибок в примерах выше не финальная, вы можете скорректировать для удоства. Главное должно быть понятно, где
именно произошла ошибка при вложенности.

Как вариант, в задание предложено подобное адт ошибок:

* `WrongType` - `JsonReader` нашел поле с нужным именем, но оно оказалось неподходящего типа для конструирования
  типа `А`.
* `AbsentField` - `JsonReader` не нашел нужного поля в исходном `Json`
* Вы можете дополнять/модифицировать адт ошибок, если считаете предложенное недостаточным. Главное не забудьте отразить
  новые ошибки в тестах.

Весь функционал покрыть тестами. В шаблоне уже есть файл с некоторыми тестами, можете менять его как посчитаете нужным.
Главное, чтобы в тестах были отражены:

1. все возможные типы Json c учетом предоставленных кейсклассов в Person
2. парсинг их из/в Json
3. использование JsonWriter[A] для JsonWriter[B], где A >: B
4. ошибки вложенных объектов

### Code Style:

Мы последовательно вводим список запрещенных механик, которыми нельзя пользоваться при написании кода, и рекомендаций по
code style. За нарушения мы оставляем за собой право **снижать оценку**.

* Переменные и функции должны иметь осмысленные названия;
* Тест классы именуются `<ClassName>Spec`, где `<ClassName>` - класс к которому пишутся тесты;
* Тест классы находятся в том же пакете, что и класс к которому пишутся тесты (например, класс `Fibonacci` находится в
  пакете `fibonacci` в директории `src/main/scala/fibonacci`, значит его тест класс `FibonacciSpec` должен быть в том же
  пакете в директории `src/test/scala/fibonacci`);
* Каждый тест должен быть в отдельном test suite;
* Использовать java коллекции запрещается (Используйте `Scala` коллекции);
* Использовать `mutable` коллекции запрещается;
* Использовать `var` запрещается;
* Использование `this` запрещается (используйте `self` если требуется);
* Использование `return` запрещается;
* Использование `System.exit` запрещается;
* Касты или проверки на типы с помощью методов из Java вроде `asInstanceOf` запрещаются;
* Использовать `throw` запрещено;
* Использование циклов запрещается (используйте `for comprehension`, `tailRec`, методы `Monad`, `fold`);
* Использование не безопасных вызовов разрешено только в тестах (например `.get` у `Option`);
* Использование взятия и освобождения примитивов синхронизации: semaphore, mutex - из разных потоков запрещено;
* Использование require для ошибок запрещается
