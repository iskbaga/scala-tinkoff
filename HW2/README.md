# Функции, рекурсия и другой зоопарк Scala

## Disclaimer:

Сборка и запуск в CI будет производиться на образе, основанном на `JVM eclipse-temurin-jammy-19.0.1`. Рекомендуем
использовать похожий JDK для локального запуска проекта, например от [Adoptium](https://adoptium.net/marketplace/)

Сборка и последующая проверка домашки будет осуществляться только, если она залита в отдельную ветку, и открыт MR.

Перед запуском тестов также проверяется форматирование кода при помощи
плагина [scalafmt](https://scalameta.org/scalafmt/docs/installation.html). Поэтому проверьте корректность форматирования
перед тем, как будете заливать свой код в репозиторий (либо на уровне IDE, либо при помощи scalafmt cli)

## Фибоначчи

Напишите функцию, которая будет вычислять число Фибоначчи через рекурсию для заданного лимита.
Ограничения задачи:

* На вход функции всегда передается валидное неотрицательное число
* Максимально может быть Long.MAX_VALUE чисел, поэтому нужно учесть возможность переполнения стэка при подсчетах.
* Так как 0 <= limit <= Long.MAX_VALUE, то в качестве результата возвращать BigInt
* Тесты уже написаны, ничего от себя добавлять не нужно

```scala=
def fibonacci(limit: Long): BigInt = ???
```

## Трансформер строк

Напишите несколько функций трансформации строки String => String:

- Дублирование строки - если передали строку "КФУ", то функция возвращает "КФУКФУ".
- Обрезание строки пополам. Нахождение середины строки округлять в меньшую сторону. Для простоты условимся, что функция
  всегда работает с непустыми строками.
- Разворот строки. Если пришло "ФУА", то на выходе будет "АУФ".

Также, напишите функцию, которая будет принимать в себя строку и функцию для ее трансформации.
При этом, необходимо, чтобы функция могла производить "замыкание" на переданной ей строке для трансформации. То есть,
при передаче в нее строки можно было бы отдельно вызывать эту функцию несколько раз, передавая любой из трансформеров,
который бы работал с исходной строкой.

Написать тесты на применения каждой из трансформации.

## Стоимость паркета в доме

В этой задаче вам необходимо смоделировать дом через один кейс класс для любого типа дома.

Дом может быть премиальным или эконом-класса, может быть несколько этажей, длина см, ширина см, высота см.
Создание кейс класса должно происходить через смарт-конструктор, который должен проверять:

* Этажи, ширина, длина, высота > 0
  Если переданы неверные данные, то бросать исключение.

Также, необходимо реализовать функцию в кейс классе для расчета стоимости паркета:

* Для премиального дома и кол-во этажей < 5:
    * 3^(кол-во этажей) * (Длина + Ширина + Высота)
* Для премиального дома и кол-во этажей >= 5:
    * 2^(кол-во этажей) * (Длина + Ширина + Высота),
* Для дома эконом-класса:
    * Длина * ширина * Высота + кол-во этажей * 10000

Функция подсчета паркета должна уметь определять тип дома через паттерн матчинг.

Написать тесты подсчет стоимости паркета для разных типов домов.

## Code style
Начиная с этой домашки, мы будем последовательно вводить список запрещенных механик, 
которыми нельзя пользоваться при написании кода, и рекомендаций по code style. 
За нарушения мы оставляем за собой право снижать оценку.

* Тест классы именуются `<ClassName>Spec`, где `<ClassName>` - класс к которому пишутся тесты;
* Тест классы находятся в том же пакете, что и класс к которому пишутся тесты (например, класс `Fibonacci` находится в пакете `fibonacci` в директории `src/main/scala/fibonacci`, значит его тест класс `FibonacciSpec` должен быть в том же пакете в директории `src/test/scala/fibonacci`);
* Использовать `var` запрещается (используйте `for comprehension`, `tailRec`)
* Использовать циклы запрещается (используйте `for comprehension`, `tailRec`)
* Использовать `return` запрещается
* Если вы бросаете исключения, то качественно смоделируйте их, а не просто используйте `Exception`
