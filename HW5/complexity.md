ПЕРВО РЕШЕНИЕ:
.sliding(k) это O(n*k) по памяти и O(n) по времени
.map(_.max) работает за O(k) для каждого окна, всего O(n*k) по времени
toList за O(1) так как map и есть список

Значит O(n*k) по времени и O(n*k) по памяти

ВТОРОЕ РЕШЕНИЕ:
Сразу заметим, что из документации scala.collection.immutable.Queue следует, что enqueue и 
dropWhile будут амортизированно работать за O(1), а значит при n запусках solveHelper(хвостовая рекурсия с одним концом) 
каждый запуск будет работать за O(1) времени, а 
значит суммарная сложность алгоритма O(1 * n) = O(n)
Для алгоритма нам достаточно хранить очередь для окна, размер которого не превышает k, значит памяти будет O(k)

Значит O(n) по времени и O(k) по памяти