# ADT и здание

1. Отразить в ADT следующую предметную область:
    1. Здание. У здания есть строковый адрес и этажи (ссылка на 1-й этаж)
    2. Этаж бывает жилым, чердаком или коммерческим
    3. У каждого жилого этажа есть 2 постояльца и лестница на следующий этаж (просто ссылка на этаж)
    4. У каждого коммерческого этажа есть несколько заведений (минимум 1) и лестница на следующий этаж (да, в этом доме
       можно открыть свою кальянную на 5 этаже, даже если всего этажей 10 :kekw:)
    5. Чердак может быть обычным, либо тоже коммерческим, но только с 1 заведением.
    6. У постояльца есть возраст (>0) и пол (м/ж).
2. При создании здания необходимо убедиться, что все входные данные не нарушают логику обозначенной модели. Иначе,
   возвращать соответствующий тип ошибки (на разные невалидные параметры разный тип ошибки). Использование `assert`, 
   `require` и `throw` запрещено.
3. Реализовать функцию `fold` аккумулирующую целое число во время обхода здания. На каждом этаже аккумулируемое значение
   пересчитывается с помощью функции `f`, параметрами которой служат текущее значение аккумулятора и этаж (Первый
   параметр, это текущий аккумулятор. Второй, текущий этаж)
   Здание обходить снизу вверх. Аккумулятор изначально равен `accumulator`. **Вы можете менять сигнатуру типов в fold,
   если посчитаете это необходимым.**
    ```scala
    def fold(building: Building, accumulator: Int)(f: (Int, ResidentialFloor) => Int): Int = ???
    ```
4. Используя функцию `fold` посчитать количество этажей, где есть хотя бы один мужчина старше `olderThan`
   (если нет таких, то 0)
    ```scala
    def countOldManFloors(building: Building, olderThan: Int): Int = ???
    ```
5. Используя функцию `fold` посчитать максимальный возраст женщины в здании
   (если нет женщин, то `None`)
    ```scala
    def womanMaxAge(building: Building): Option[Int] = ???
    ```
6. Используя функцию `fold` посчитать кол-во коммерческих заведений в здании (если нет, то 0)
    ```scala
    def countCommercial(building: Building): Int = ???
    ```
7. Используя свою собственную функцию, похожую на `fold`, посчитать среднее кол-во коммерческих заведений в зданиях (
   если нет, то 0). Если знаете, как работать с тайп параметрами в функциях, то можно изменить сигнатуру самой
   функции `fold`, и использовать ее.
    ```scala
    def countCommercial(building: Array[Building]): Double = ???
    ```
8. Используя свою собственную функцию, похожую на `fold`, посчитать среднее кол-во мужчин на четных этажах (если нет, то
   0) 
    ```scala
    def evenFloorsMenAvg(building: Building): Double = ???
    ```
9. Напишите тесты в BuildingSpec.scala. На функцию fold отдельные тесты писать не обязательно

### Code Style:

Мы последовательно вводим список запрещенных механик, которыми нельзя пользоваться при написании кода, и рекомендаций по
code style. За нарушения мы оставляем за собой право **снижать оценку**.

* Переменные и функции должны иметь осмысленные названия;
* Тест классы именуются `<ClassName>Spec`, где `<ClassName>` - класс к которому пишутся тесты;
* Тест классы находятся в том же пакете, что и класс к которому пишутся тесты (например, класс `Fibonacci` находится в
  пакете `fibonacci` в директории `src/main/scala/fibonacci`, значит его тест класс `FibonacciSpec` должен быть в том же
  пакете в директории `src/test/scala/fibonacci`);
* Использовать `var` запрещается;
* Использование `return` запрещается;
* Использование `System.exit` запрещается;
* Использование циклов запрещается (используйте `for comprehension`, `tailRec`);
* Каст типов с помощью `asInstanceOf`, проверка типов через `isInstanceOf` запрещены. Обратите внимание, что в одном из следующих домашних заданий мы можем разрешить ими воспользоваться;
* Использование не безопасных вызовов разрешено только в тестах (например `.get` у `Option`);
* Запрещено кидать ошибки через `throw`. Для моделирования кода, который может бросить ошибку разрешено использовать только `Option`, `Either`, `Try`;
* Пайплайны в Merge Request обязательно должны проходить и быть зелеными, и при этом должны запускаться scalafmt и тесты;
* Правки в условиях запрещены. Разрешено делать это только отдельным MR в `upstream`, где вы можете указать нам на недочет в условии задания;
